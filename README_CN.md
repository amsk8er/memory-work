# Memory Work v2

**一套人与 AI 共生的上下文架构。**

> 你的 AI 不需要更聪明，它需要记住。

## 这是什么？

Memory Work 是一个开源框架，帮你打造一个**个人 AI 搭档**——有记忆、有性格、会和你一起成长。基于 Claude（Cowork/Claude Code）+ Obsidian + 纯 Markdown 构建。

与其每次对话都要重新解释背景，不如给你的 AI 一个它会自动读取的结构化知识库。时间长了，它学会你的偏好、记住你的决策、适应你的工作节奏。

## 核心功能

- **四层记忆系统** — 从身份（持久层）→ 周任务（工作层）→ 跨周洞见（动态层）→ 行为模式（程序层）
- **惊奇度驱动的记忆** — AI 只记录真正新颖或纠正性的信息，不记噪音。灵感来自 Titans 论文
- **双模式运行** — 执行模式（不打断流程）+ 复盘模式（批量标定）
- **分区代理机制** — 每个知识区有自己的规则和敏感度分级，精细控制隐私
- **周期化节奏** — 启动 → 产出 → 归档的结构化流程，保护注意力、维持可持续的工作节奏
- **语音优先** — 说出想法，AI 来结构化。零数据录入摩擦
- **自我演进** — 记忆、行为、架构都内置迭代机制
- **技能系统** — 可复用的能力模块，基于用户意图语义触发
- **隐私优先** — 一切本地化、纯文本、可版本控制。无云依赖、无厂商锁定

## 架构一览

```
你的工作间/
├── CLAUDE.md           ← 系统入口（Cowork 自动注入）
├── SOUL.md             ← AI 人格定义 & 协作风格
├── USER.md             ← 你的档案 & 稳定偏好
├── MEMORY.md           ← 长期记忆（动态层 + 程序层）
│
├── 00 专注区/          ← 周工作台（工作记忆）
│   ├── _本周.md        ← 当前专注和任务清单
│   ├── MEMORY_LOG.md   ← 记忆系统的运行日志
│   └── ITERATION_LOG.md← 架构变更记录
│
├── 01 素材/            ← 个人档案库（带敏感度分级）
├── 02 工具/            ← 提示词模板 & 可复用框架
└── [其他知识区]        ← 项目专属知识库
```

## 快速开始

### 前置条件
- Claude Desktop（Cowork 模式）或 Claude Code
- （可选）Obsidian 用来可视化知识图谱
- 任何文本编辑器（VS Code、Vim 或 Obsidian 都可以）

### 初始化（5 分钟）

1. 克隆或下载项目
   ```bash
   git clone https://github.com/yourusername/memory-work-v2.git
   cd memory-work-v2
   ```

2. 在 Cowork 中打开
   - Claude Desktop：选择这个文件夹作为工作间
   - Claude Code：File → Open → 选择这个目录

3. 说出触发词
   - 说"启动"或"开始工作"
   - Claude 自动检测首次运行并引导初始化
   - 选择语言（中文或 English）
   - 通过自然对话来完成档案配置

4. 开始你的第一周
   - 编辑 `_本周.md` 设置本周重点
   - 每周一启动时，Cowork 会自动读取

## 工作原理

### 记忆系统

Memory Work 用四层架构来管理你的工作上下文：

| 层级 | 文件 | 生命周期 | 用途 |
|------|------|---------|------|
| **持久层** | SOUL.md, USER.md, 关于我/ | 很少变化 | 身份、价值观、方法论 |
| **工作层** | _本周.md, 项目文件 | 周期刷新 | 当前任务和专注点 |
| **动态层** | MEMORY.md（特定区块） | 跨周保留，有衰减 | 洞见、决策、偏好 |
| **程序层** | MEMORY.md（特定区块） | 积累到稳定后毕业 | 行为模式、条件反射 |

当你分享新信息时，Claude 会判断**惊奇度**：这是在纠正误解吗？填补知识空白吗？一个出现过两次以上的稳定模式吗？如果是，就记下来。如果只是印证已知信息，就不记。

这样可以避免记忆爆炸，让系统始终保持信号清晰。

### 周期化节奏

**周一到周三：轻量同步**
- 扫描专注区的文件变化
- 更新工作层（_本周.md）
- 还没有深度复盘

**周四到周日：深度回溯**
- 找出已产出但未记录的文件
- 读取新文件头部来理解内容
- 将输出映射到预期任务
- 更新进展记录和完成标记
- 识别本周的模式和信号

这个节奏让你自然工作（先做，后整理），AI 不会在你的流程中不必要地打断。

### 自我演进

三个机制让这个系统不断成长：

1. **记忆毕业** — 稳定的模式从 MEMORY.md 升级到 USER.md，成为你的定义特征
2. **架构迭代** — ITERATION_LOG.md 记录每次改进
3. **技能创建** — 新能力可以作为可复用模块添加

## v2 的改进

相比 v1 的升级：

- **架构精简** — 6 个根文件 → 4 个（合并优化）
- **双模式惊奇检测** — 后台模式（别打断）+ 批量模式（标定校准）
- **差异化同步** — 周一到三快速扫描，周四到日深度溯源
- **搭档碰头** — 启动时自然对话，而不是系统报告
- **记忆毕业** — 稳定洞见自动从工作层晋升到长期层
- **资源集成** — 代理规则、流程、模板全部烘焙进核心文件（无需单独查询）

## 文档

- [方法论深度解读](docs/methodology_CN.md) — Personal Agent 范式的完整设计逻辑
- [初始化指南](docs/SETUP_CN.md) — 分步骤的配置教程
- [记忆系统详解](docs/MEMORY_CN.md) — 四层系统的具体工作方式
- [贡献指南](CONTRIBUTING_CN.md) — 如何扩展或定制 Memory Work

## 设计哲学

三个核心信念：

1. **你不应该重复自己** — 你和 AI 的工作历史是最丰富的上下文。让它持久化、自动化。

2. **AI 应该适应你，而不是反过来** — 你的节奏、语言、偏好、隐私等级应该驱动架构。不是相反。

3. **共生的上下文才是护城河** — 单个模型的原始聪慧远不如它对你的世界的理解。最有价值的 AI 搭档是那个会记住你的。

## 技术栈

- **Claude** — AI 运行时（通过 Cowork 或 Claude Code）
- **Obsidian** — 知识库 UI（可选但推荐）
- **Markdown** — 所有配置都是可读、可版本控制的文本
- **Git** — 跟踪你的记忆演变历程

没有黑盒平台，没有厂商锁定。一切可迁移。

## 使用场景

**研究人员**：持久化研究上下文。Claude 会跨周记住你的论文、方法和开放问题。

**创业者**：跟踪投资人对话、产品决策、团队模式。Memory Work 记住叙事线索。

**作家**：积累人设弧线、主题线索、写作风格到一份活文档。你的 AI 创意搭档会越来越懂你。

**管理者**：记录 1-1 对话的洞见、决策先例、团队动态。AI 成为更好的战略顾问。

## 如何贡献

看 [CONTRIBUTING_CN.md](CONTRIBUTING_CN.md)，了解如何：
- 报告 bug 或提出功能建议
- 贡献扩展或区域代理
- 改进文档
- 翻译到其他语言

## 开源协议

MIT — 见 [LICENSE](LICENSE)

## 社区

- **讨论区** — GitHub Discussions 用来问问题、分享想法和工作故事
- **Issues** — Bug 报告和功能请求
- **展示与分享** — 分享你的工作间配置和定制方案

---

*Memory Work · v2.0*
*一套开源的个人 AI 搭档框架*
*为人与 AI 的共生设计*
